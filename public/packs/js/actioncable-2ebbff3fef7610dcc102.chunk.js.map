{"version":3,"sources":["webpack:///./node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/adapters.js","webpack:///./node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/logger.js","webpack:///./node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/connection_monitor.js","webpack:///./node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/internal.js","webpack:///./node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/connection.js","webpack:///./node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/subscription.js","webpack:///./node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/subscription_guarantor.js","webpack:///./node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/subscriptions.js","webpack:///./node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/consumer.js","webpack:///./node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/index.js"],"names":["logger","self","console","WebSocket","log","this","enabled","_len","arguments","length","messages","Array","_key","push","Date","now","adapters","getTime","secondsSince","time","constructor","connection","visibilityDidChange","bind","reconnectAttempts","start","isRunning","startedAt","stoppedAt","startPolling","addEventListener","concat","staleThreshold","stop","stopPolling","removeEventListener","recordPing","pingedAt","recordConnect","disconnectedAt","recordDisconnect","poll","clearTimeout","pollTimeout","setTimeout","reconnectIfStale","getPollInterval","_this$constructor","reconnectionBackoffRate","Math","pow","min","random","connectionIsStale","refreshedAt","disconnectedRecently","reopen","document","visibilityState","isOpen","message_types","protocols","supportedProtocols","slice","indexOf","consumer","open","subscriptions","monitor","disconnected","send","data","webSocket","JSON","stringify","isActive","getState","uninstallEventHandlers","url","installEventHandlers","close","undefined","allowReconnect","error","reopenDelay","getProtocol","protocol","isState","isProtocolSupported","call","states","state","readyState","toLowerCase","eventName","events","handler","prototype","message","event","_JSON$parse","parse","identifier","reason","reconnect","type","welcome","reload","disconnect","ping","confirmation","confirmSubscription","notify","rejection","reject","notifyAll","willAttemptReconnect","Subscription","params","mixin","object","properties","key","value","extend","perform","action","command","unsubscribe","remove","pendingSubscriptions","guarantee","subscription","startGuaranteeing","forget","filter","s","stopGuaranteeing","retrySubscribing","retryTimeout","subscribe","map","guarantor","create","channelName","channel","add","ensureActiveConnection","findAll","sendCommand","callbackName","args","_len2","_key2","_url","createWebSocketURL","connect","test","a","createElement","href","replace","createConsumer","getConfig","default_mount_path","name","element","head","querySelector","getAttribute"],"mappings":"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","file":"js/actioncable-2ebbff3fef7610dcc102.chunk.js","sourcesContent":["export default {\n  logger: self.console,\n  WebSocket: self.WebSocket\n};","import adapters from \"./adapters\"; // The logger is disabled by default. You can enable it with:\n//\n//   ActionCable.logger.enabled = true\n//\n//   Example:\n//\n//   import * as ActionCable from '@rails/actioncable'\n//\n//   ActionCable.logger.enabled = true\n//   ActionCable.logger.log('Connection Established.')\n//\n\nexport default {\n  log() {\n    if (this.enabled) {\n      for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) {\n        messages[_key] = arguments[_key];\n      }\n\n      messages.push(Date.now());\n      adapters.logger.log(\"[ActionCable]\", ...messages);\n    }\n  }\n\n};","import logger from \"./logger\"; // Responsible for ensuring the cable connection is in good health by validating the heartbeat pings sent from the server, and attempting\n// revival reconnections if things go astray. Internal class, not intended for direct user manipulation.\n\nconst now = () => new Date().getTime();\n\nconst secondsSince = time => (now() - time) / 1000;\n\nclass ConnectionMonitor {\n  constructor(connection) {\n    this.visibilityDidChange = this.visibilityDidChange.bind(this);\n    this.connection = connection;\n    this.reconnectAttempts = 0;\n  }\n\n  start() {\n    if (!this.isRunning()) {\n      this.startedAt = now();\n      delete this.stoppedAt;\n      this.startPolling();\n      addEventListener(\"visibilitychange\", this.visibilityDidChange);\n      logger.log(\"ConnectionMonitor started. stale threshold = \".concat(this.constructor.staleThreshold, \" s\"));\n    }\n  }\n\n  stop() {\n    if (this.isRunning()) {\n      this.stoppedAt = now();\n      this.stopPolling();\n      removeEventListener(\"visibilitychange\", this.visibilityDidChange);\n      logger.log(\"ConnectionMonitor stopped\");\n    }\n  }\n\n  isRunning() {\n    return this.startedAt && !this.stoppedAt;\n  }\n\n  recordPing() {\n    this.pingedAt = now();\n  }\n\n  recordConnect() {\n    this.reconnectAttempts = 0;\n    this.recordPing();\n    delete this.disconnectedAt;\n    logger.log(\"ConnectionMonitor recorded connect\");\n  }\n\n  recordDisconnect() {\n    this.disconnectedAt = now();\n    logger.log(\"ConnectionMonitor recorded disconnect\");\n  } // Private\n\n\n  startPolling() {\n    this.stopPolling();\n    this.poll();\n  }\n\n  stopPolling() {\n    clearTimeout(this.pollTimeout);\n  }\n\n  poll() {\n    this.pollTimeout = setTimeout(() => {\n      this.reconnectIfStale();\n      this.poll();\n    }, this.getPollInterval());\n  }\n\n  getPollInterval() {\n    const _this$constructor = this.constructor,\n          staleThreshold = _this$constructor.staleThreshold,\n          reconnectionBackoffRate = _this$constructor.reconnectionBackoffRate;\n    const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));\n    const jitterMax = this.reconnectAttempts === 0 ? 1.0 : reconnectionBackoffRate;\n    const jitter = jitterMax * Math.random();\n    return staleThreshold * 1000 * backoff * (1 + jitter);\n  }\n\n  reconnectIfStale() {\n    if (this.connectionIsStale()) {\n      logger.log(\"ConnectionMonitor detected stale connection. reconnectAttempts = \".concat(this.reconnectAttempts, \", time stale = \").concat(secondsSince(this.refreshedAt), \" s, stale threshold = \").concat(this.constructor.staleThreshold, \" s\"));\n      this.reconnectAttempts++;\n\n      if (this.disconnectedRecently()) {\n        logger.log(\"ConnectionMonitor skipping reopening recent disconnect. time disconnected = \".concat(secondsSince(this.disconnectedAt), \" s\"));\n      } else {\n        logger.log(\"ConnectionMonitor reopening\");\n        this.connection.reopen();\n      }\n    }\n  }\n\n  get refreshedAt() {\n    return this.pingedAt ? this.pingedAt : this.startedAt;\n  }\n\n  connectionIsStale() {\n    return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;\n  }\n\n  disconnectedRecently() {\n    return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;\n  }\n\n  visibilityDidChange() {\n    if (document.visibilityState === \"visible\") {\n      setTimeout(() => {\n        if (this.connectionIsStale() || !this.connection.isOpen()) {\n          logger.log(\"ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = \".concat(document.visibilityState));\n          this.connection.reopen();\n        }\n      }, 200);\n    }\n  }\n\n}\n\nConnectionMonitor.staleThreshold = 6; // Server::Connections::BEAT_INTERVAL * 2 (missed two pings)\n\nConnectionMonitor.reconnectionBackoffRate = 0.15;\nexport default ConnectionMonitor;","export default {\n  \"message_types\": {\n    \"welcome\": \"welcome\",\n    \"disconnect\": \"disconnect\",\n    \"ping\": \"ping\",\n    \"confirmation\": \"confirm_subscription\",\n    \"rejection\": \"reject_subscription\"\n  },\n  \"disconnect_reasons\": {\n    \"unauthorized\": \"unauthorized\",\n    \"invalid_request\": \"invalid_request\",\n    \"server_restart\": \"server_restart\"\n  },\n  \"default_mount_path\": \"/cable\",\n  \"protocols\": [\"actioncable-v1-json\", \"actioncable-unsupported\"]\n};","import adapters from \"./adapters\";\nimport ConnectionMonitor from \"./connection_monitor\";\nimport INTERNAL from \"./internal\";\nimport logger from \"./logger\"; // Encapsulate the cable connection held by the consumer. This is an internal class not intended for direct user manipulation.\n\nconst message_types = INTERNAL.message_types,\n      protocols = INTERNAL.protocols;\nconst supportedProtocols = protocols.slice(0, protocols.length - 1);\nconst indexOf = [].indexOf;\n\nclass Connection {\n  constructor(consumer) {\n    this.open = this.open.bind(this);\n    this.consumer = consumer;\n    this.subscriptions = this.consumer.subscriptions;\n    this.monitor = new ConnectionMonitor(this);\n    this.disconnected = true;\n  }\n\n  send(data) {\n    if (this.isOpen()) {\n      this.webSocket.send(JSON.stringify(data));\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  open() {\n    if (this.isActive()) {\n      logger.log(\"Attempted to open WebSocket, but existing socket is \".concat(this.getState()));\n      return false;\n    } else {\n      logger.log(\"Opening WebSocket, current state is \".concat(this.getState(), \", subprotocols: \").concat(protocols));\n\n      if (this.webSocket) {\n        this.uninstallEventHandlers();\n      }\n\n      this.webSocket = new adapters.WebSocket(this.consumer.url, protocols);\n      this.installEventHandlers();\n      this.monitor.start();\n      return true;\n    }\n  }\n\n  close() {\n    let _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      allowReconnect: true\n    },\n        allowReconnect = _ref.allowReconnect;\n\n    if (!allowReconnect) {\n      this.monitor.stop();\n    } // Avoid closing websockets in a \"connecting\" state due to Safari 15.1+ bug. See: https://github.com/rails/rails/issues/43835#issuecomment-1002288478\n\n\n    if (this.isOpen()) {\n      return this.webSocket.close();\n    }\n  }\n\n  reopen() {\n    logger.log(\"Reopening WebSocket, current state is \".concat(this.getState()));\n\n    if (this.isActive()) {\n      try {\n        return this.close();\n      } catch (error) {\n        logger.log(\"Failed to reopen WebSocket\", error);\n      } finally {\n        logger.log(\"Reopening WebSocket in \".concat(this.constructor.reopenDelay, \"ms\"));\n        setTimeout(this.open, this.constructor.reopenDelay);\n      }\n    } else {\n      return this.open();\n    }\n  }\n\n  getProtocol() {\n    if (this.webSocket) {\n      return this.webSocket.protocol;\n    }\n  }\n\n  isOpen() {\n    return this.isState(\"open\");\n  }\n\n  isActive() {\n    return this.isState(\"open\", \"connecting\");\n  } // Private\n\n\n  isProtocolSupported() {\n    return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;\n  }\n\n  isState() {\n    for (var _len = arguments.length, states = new Array(_len), _key = 0; _key < _len; _key++) {\n      states[_key] = arguments[_key];\n    }\n\n    return indexOf.call(states, this.getState()) >= 0;\n  }\n\n  getState() {\n    if (this.webSocket) {\n      for (let state in adapters.WebSocket) {\n        if (adapters.WebSocket[state] === this.webSocket.readyState) {\n          return state.toLowerCase();\n        }\n      }\n    }\n\n    return null;\n  }\n\n  installEventHandlers() {\n    for (let eventName in this.events) {\n      const handler = this.events[eventName].bind(this);\n      this.webSocket[\"on\".concat(eventName)] = handler;\n    }\n  }\n\n  uninstallEventHandlers() {\n    for (let eventName in this.events) {\n      this.webSocket[\"on\".concat(eventName)] = function () {};\n    }\n  }\n\n}\n\nConnection.reopenDelay = 500;\nConnection.prototype.events = {\n  message(event) {\n    if (!this.isProtocolSupported()) {\n      return;\n    }\n\n    const _JSON$parse = JSON.parse(event.data),\n          identifier = _JSON$parse.identifier,\n          message = _JSON$parse.message,\n          reason = _JSON$parse.reason,\n          reconnect = _JSON$parse.reconnect,\n          type = _JSON$parse.type;\n\n    switch (type) {\n      case message_types.welcome:\n        this.monitor.recordConnect();\n        return this.subscriptions.reload();\n\n      case message_types.disconnect:\n        logger.log(\"Disconnecting. Reason: \".concat(reason));\n        return this.close({\n          allowReconnect: reconnect\n        });\n\n      case message_types.ping:\n        return this.monitor.recordPing();\n\n      case message_types.confirmation:\n        this.subscriptions.confirmSubscription(identifier);\n        return this.subscriptions.notify(identifier, \"connected\");\n\n      case message_types.rejection:\n        return this.subscriptions.reject(identifier);\n\n      default:\n        return this.subscriptions.notify(identifier, \"received\", message);\n    }\n  },\n\n  open() {\n    logger.log(\"WebSocket onopen event, using '\".concat(this.getProtocol(), \"' subprotocol\"));\n    this.disconnected = false;\n\n    if (!this.isProtocolSupported()) {\n      logger.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n      return this.close({\n        allowReconnect: false\n      });\n    }\n  },\n\n  close(event) {\n    logger.log(\"WebSocket onclose event\");\n\n    if (this.disconnected) {\n      return;\n    }\n\n    this.disconnected = true;\n    this.monitor.recordDisconnect();\n    return this.subscriptions.notifyAll(\"disconnected\", {\n      willAttemptReconnect: this.monitor.isRunning()\n    });\n  },\n\n  error() {\n    logger.log(\"WebSocket onerror event\");\n  }\n\n};\nexport default Connection;","// A new subscription is created through the ActionCable.Subscriptions instance available on the consumer.\n// It provides a number of callbacks and a method for calling remote procedure calls on the corresponding\n// Channel instance on the server side.\n//\n// An example demonstrates the basic functionality:\n//\n//   App.appearance = App.cable.subscriptions.create(\"AppearanceChannel\", {\n//     connected() {\n//       // Called once the subscription has been successfully completed\n//     },\n//\n//     disconnected({ willAttemptReconnect: boolean }) {\n//       // Called when the client has disconnected with the server.\n//       // The object will have an `willAttemptReconnect` property which\n//       // says whether the client has the intention of attempting\n//       // to reconnect.\n//     },\n//\n//     appear() {\n//       this.perform('appear', {appearing_on: this.appearingOn()})\n//     },\n//\n//     away() {\n//       this.perform('away')\n//     },\n//\n//     appearingOn() {\n//       $('main').data('appearing-on')\n//     }\n//   })\n//\n// The methods #appear and #away forward their intent to the remote AppearanceChannel instance on the server\n// by calling the `perform` method with the first parameter being the action (which maps to AppearanceChannel#appear/away).\n// The second parameter is a hash that'll get JSON encoded and made available on the server in the data parameter.\n//\n// This is how the server component would look:\n//\n//   class AppearanceChannel < ApplicationActionCable::Channel\n//     def subscribed\n//       current_user.appear\n//     end\n//\n//     def unsubscribed\n//       current_user.disappear\n//     end\n//\n//     def appear(data)\n//       current_user.appear on: data['appearing_on']\n//     end\n//\n//     def away\n//       current_user.away\n//     end\n//   end\n//\n// The \"AppearanceChannel\" name is automatically mapped between the client-side subscription creation and the server-side Ruby class name.\n// The AppearanceChannel#appear/away public methods are exposed automatically to client-side invocation through the perform method.\nconst extend = function (object, properties) {\n  if (properties != null) {\n    for (let key in properties) {\n      const value = properties[key];\n      object[key] = value;\n    }\n  }\n\n  return object;\n};\n\nexport default class Subscription {\n  constructor(consumer) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let mixin = arguments.length > 2 ? arguments[2] : undefined;\n    this.consumer = consumer;\n    this.identifier = JSON.stringify(params);\n    extend(this, mixin);\n  } // Perform a channel action with the optional data passed as an attribute\n\n\n  perform(action) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    data.action = action;\n    return this.send(data);\n  }\n\n  send(data) {\n    return this.consumer.send({\n      command: \"message\",\n      identifier: this.identifier,\n      data: JSON.stringify(data)\n    });\n  }\n\n  unsubscribe() {\n    return this.consumer.subscriptions.remove(this);\n  }\n\n}","import logger from \"./logger\"; // Responsible for ensuring channel subscribe command is confirmed, retrying until confirmation is received.\n// Internal class, not intended for direct user manipulation.\n\nclass SubscriptionGuarantor {\n  constructor(subscriptions) {\n    this.subscriptions = subscriptions;\n    this.pendingSubscriptions = [];\n  }\n\n  guarantee(subscription) {\n    if (this.pendingSubscriptions.indexOf(subscription) == -1) {\n      logger.log(\"SubscriptionGuarantor guaranteeing \".concat(subscription.identifier));\n      this.pendingSubscriptions.push(subscription);\n    } else {\n      logger.log(\"SubscriptionGuarantor already guaranteeing \".concat(subscription.identifier));\n    }\n\n    this.startGuaranteeing();\n  }\n\n  forget(subscription) {\n    logger.log(\"SubscriptionGuarantor forgetting \".concat(subscription.identifier));\n    this.pendingSubscriptions = this.pendingSubscriptions.filter(s => s !== subscription);\n  }\n\n  startGuaranteeing() {\n    this.stopGuaranteeing();\n    this.retrySubscribing();\n  }\n\n  stopGuaranteeing() {\n    clearTimeout(this.retryTimeout);\n  }\n\n  retrySubscribing() {\n    this.retryTimeout = setTimeout(() => {\n      if (this.subscriptions && typeof this.subscriptions.subscribe === \"function\") {\n        this.pendingSubscriptions.map(subscription => {\n          logger.log(\"SubscriptionGuarantor resubscribing \".concat(subscription.identifier));\n          this.subscriptions.subscribe(subscription);\n        });\n      }\n    }, 500);\n  }\n\n}\n\nexport default SubscriptionGuarantor;","import Subscription from \"./subscription\";\nimport SubscriptionGuarantor from \"./subscription_guarantor\";\nimport logger from \"./logger\"; // Collection class for creating (and internally managing) channel subscriptions.\n// The only method intended to be triggered by the user is ActionCable.Subscriptions#create,\n// and it should be called through the consumer like so:\n//\n//   App = {}\n//   App.cable = ActionCable.createConsumer(\"ws://example.com/accounts/1\")\n//   App.appearance = App.cable.subscriptions.create(\"AppearanceChannel\")\n//\n// For more details on how you'd configure an actual channel subscription, see ActionCable.Subscription.\n\nexport default class Subscriptions {\n  constructor(consumer) {\n    this.consumer = consumer;\n    this.guarantor = new SubscriptionGuarantor(this);\n    this.subscriptions = [];\n  }\n\n  create(channelName, mixin) {\n    const channel = channelName;\n    const params = typeof channel === \"object\" ? channel : {\n      channel\n    };\n    const subscription = new Subscription(this.consumer, params, mixin);\n    return this.add(subscription);\n  } // Private\n\n\n  add(subscription) {\n    this.subscriptions.push(subscription);\n    this.consumer.ensureActiveConnection();\n    this.notify(subscription, \"initialized\");\n    this.subscribe(subscription);\n    return subscription;\n  }\n\n  remove(subscription) {\n    this.forget(subscription);\n\n    if (!this.findAll(subscription.identifier).length) {\n      this.sendCommand(subscription, \"unsubscribe\");\n    }\n\n    return subscription;\n  }\n\n  reject(identifier) {\n    return this.findAll(identifier).map(subscription => {\n      this.forget(subscription);\n      this.notify(subscription, \"rejected\");\n      return subscription;\n    });\n  }\n\n  forget(subscription) {\n    this.guarantor.forget(subscription);\n    this.subscriptions = this.subscriptions.filter(s => s !== subscription);\n    return subscription;\n  }\n\n  findAll(identifier) {\n    return this.subscriptions.filter(s => s.identifier === identifier);\n  }\n\n  reload() {\n    return this.subscriptions.map(subscription => this.subscribe(subscription));\n  }\n\n  notifyAll(callbackName) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return this.subscriptions.map(subscription => this.notify(subscription, callbackName, ...args));\n  }\n\n  notify(subscription, callbackName) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      args[_key2 - 2] = arguments[_key2];\n    }\n\n    let subscriptions;\n\n    if (typeof subscription === \"string\") {\n      subscriptions = this.findAll(subscription);\n    } else {\n      subscriptions = [subscription];\n    }\n\n    return subscriptions.map(subscription => typeof subscription[callbackName] === \"function\" ? subscription[callbackName](...args) : undefined);\n  }\n\n  subscribe(subscription) {\n    if (this.sendCommand(subscription, \"subscribe\")) {\n      this.guarantor.guarantee(subscription);\n    }\n  }\n\n  confirmSubscription(identifier) {\n    logger.log(\"Subscription confirmed \".concat(identifier));\n    this.findAll(identifier).map(subscription => this.guarantor.forget(subscription));\n  }\n\n  sendCommand(subscription, command) {\n    const identifier = subscription.identifier;\n    return this.consumer.send({\n      command,\n      identifier\n    });\n  }\n\n}","import Connection from \"./connection\";\nimport Subscriptions from \"./subscriptions\"; // The ActionCable.Consumer establishes the connection to a server-side Ruby Connection object. Once established,\n// the ActionCable.ConnectionMonitor will ensure that its properly maintained through heartbeats and checking for stale updates.\n// The Consumer instance is also the gateway to establishing subscriptions to desired channels through the #createSubscription\n// method.\n//\n// The following example shows how this can be set up:\n//\n//   App = {}\n//   App.cable = ActionCable.createConsumer(\"ws://example.com/accounts/1\")\n//   App.appearance = App.cable.subscriptions.create(\"AppearanceChannel\")\n//\n// For more details on how you'd configure an actual channel subscription, see ActionCable.Subscription.\n//\n// When a consumer is created, it automatically connects with the server.\n//\n// To disconnect from the server, call\n//\n//   App.cable.disconnect()\n//\n// and to restart the connection:\n//\n//   App.cable.connect()\n//\n// Any channel subscriptions which existed prior to disconnecting will\n// automatically resubscribe.\n\nexport default class Consumer {\n  constructor(url) {\n    this._url = url;\n    this.subscriptions = new Subscriptions(this);\n    this.connection = new Connection(this);\n  }\n\n  get url() {\n    return createWebSocketURL(this._url);\n  }\n\n  send(data) {\n    return this.connection.send(data);\n  }\n\n  connect() {\n    return this.connection.open();\n  }\n\n  disconnect() {\n    return this.connection.close({\n      allowReconnect: false\n    });\n  }\n\n  ensureActiveConnection() {\n    if (!this.connection.isActive()) {\n      return this.connection.open();\n    }\n  }\n\n}\nexport function createWebSocketURL(url) {\n  if (typeof url === \"function\") {\n    url = url();\n  }\n\n  if (url && !/^wss?:/i.test(url)) {\n    const a = document.createElement(\"a\");\n    a.href = url; // Fix populating Location properties in IE. Otherwise, protocol will be blank.\n\n    a.href = a.href;\n    a.protocol = a.protocol.replace(\"http\", \"ws\");\n    return a.href;\n  } else {\n    return url;\n  }\n}","import Connection from \"./connection\";\nimport ConnectionMonitor from \"./connection_monitor\";\nimport Consumer, { createWebSocketURL } from \"./consumer\";\nimport INTERNAL from \"./internal\";\nimport Subscription from \"./subscription\";\nimport Subscriptions from \"./subscriptions\";\nimport SubscriptionGuarantor from \"./subscription_guarantor\";\nimport adapters from \"./adapters\";\nimport logger from \"./logger\";\nexport { Connection, ConnectionMonitor, Consumer, INTERNAL, Subscription, Subscriptions, SubscriptionGuarantor, adapters, createWebSocketURL, logger };\nexport function createConsumer() {\n  let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getConfig(\"url\") || INTERNAL.default_mount_path;\n  return new Consumer(url);\n}\nexport function getConfig(name) {\n  const element = document.head.querySelector(\"meta[name='action-cable-\".concat(name, \"']\"));\n\n  if (element) {\n    return element.getAttribute(\"content\");\n  }\n}"],"sourceRoot":""}